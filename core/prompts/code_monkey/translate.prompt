{#你正在一个将 C工程 迁移到 Rust工程 的项目组工作，你的任务是完成组长分配的任务。#}
{#组长会告知你当前小组的全部任务以及你需要完成的任务，你只需要完成你的任务，不需要完成其他任务。#}
你将收到用 C 或 C++ 编写的代码。你的任务是**阅读并理解 C/C++ 代码，考虑 Rust 中是否已有等价的实现，若没有，则将其转译为等价的 Rust 代码；若有，则无需转译，给出解释即可。**。

{% include "code_monkey/translation_context.prompt" %}

# 请按照以下步骤进行思考：

## 步骤#1：理解原始的 C/C++ 代码
- **阅读代码**：通读提供的 C/C++ 代码，理解其功能、结构和逻辑。
- **识别关键组件**：
{% if "struct" in node_types or "enum" in node_types or "union" in node_types %}
    - **数据结构**：找出所有的结构体、联合体、枚举等。
{% elif "function" in node_types %}
    - **函数**：列出所有函数，了解它们的参数、返回值和实现细节。
{% elif "typedef" in node_types or "macro" in node_types %}
    - **宏和类型定义**：注意任何宏定义或类型别名，这些可能需要在 Rust 中特殊处理。
{% endif %}
- **分析代码逻辑**：理解各个函数之间的关系，数据如何在函数之间传递和修改。

## 步骤#2：决定需要转译的部分和方式
{% if "struct" in node_types or "enum" in node_types or "union" in node_types %}
- **数据结构**：
{#    - **利用 Rust 标准库**：如果 C/C++ 代码手动管理内存或数据结构，考虑使用 Rust 的标准数据结构（如 Vec<T>）来替代。#}
    - **简化结构体**：删除在 Rust 中不再需要的字段（如手动管理的长度和容量）。
    - **泛型化**：使用泛型 <T>，替代 C/C++ 中的 void*，提高类型安全性。
    - **派生特性**：为结构体或枚举实现常用派生特性 Debug、Clone、PartialEq、Eq、Default 等特性。
    - **替代裸指针**：使用引用或智能指针（Box、Rc、RefCell、Arc、Mutex、RwLock等），避免裸指针，确保内存安全，**优先使用 RefCell 来实现内部可变性。**
{% elif "function" in node_types %}
- **函数**：
    - **是否需要转译**：若函数在 Rust 中已经存在对应的标准库函数，或 Debug、Clone、PartialEq、Ord 等特性中已经定义了相应的方法，则不需要转译，但需要编写注释说明。
    - **转译为方法**：如果函数与某个结构体相关，在 Rust 中将其作为该结构体的关联方法，并使用 **impl** 块包裹。
    - **调整参数**：利用 Rust 的所有权和借用机制，使用 &self 或 &mut self 代替显式传递指针。
    - **错误处理**：使用 Result 或 Option 来处理可能的错误或无效情况，而不是返回错误码。
    - **避免不必要的函数参数**：如果可以通过标准特性（如 `PartialEq`、`Ord`）实现功能，**不要**引入额外的函数参数（如自定义的比较函数或谓词）。
{% elif "typedef" in node_types %}
- **类型声明**：
    - **使用标准特性**：如果类型定义涉及函数指针（如比较函数），考虑使用 Rust 的标准特性（如 PartialEq、Ord）替代。
    - **删除不必要的类型别名**：如果类型别名在 Rust 中不再需要，可以省略，但需要编写注释说明。
{% endif %}

## 步骤#3：按照 Rust 的最佳实践进行转译

- **所有权和借用**：
    - **避免裸指针**：详细分析该模块的功能，选择使用引用或智能指针(Box、Rc、RefCell、Arc、Mutex、RwLock等)，确保内存安全，**优先使用 RefCell 来实现内部可变性。**
        - **引用**：临时访问，函数参数，避免所有权转移。
        - **Box**：堆分配，单一所有权，固定大小。
        - **Rc**：不可变共享，引用计数。
        - **RefCell**：内部可变性，动态借用。
        - **Arc**：线程安全共享，原子引用计数。
        - **Mutex**：互斥访问，内部可变性，线程安全。
        - **RwLock**：读写锁，多读单写，线程安全。
    - **生命周期**：必要时标注生命周期，但尽量利用编译器的生命周期省略规则。
- **错误处理**：
    - **使用 Option 和 Result**：优雅地处理可能的错误或异常情况。
    - **避免 unwrap**：除非绝对确定有值，否则避免直接解包，防止潜在的崩溃。
- **利用标准库功能**：
    - **数据结构操作**：使用 Vec<T> 的内置方法，如 push、insert、remove 等。
    - **排序和查找**：利用迭代器和排序方法，如 sort、iter().position()。
- **实现特性（Traits）**：
    - **Derive 常用特性**：为结构体或枚举派生 Debug、Clone、PartialEq 等特性。
    - **自定义特性**：如果需要特殊行为，考虑定义和实现自定义特性。
- **代码风格和规范**：
    - **命名规范**：类型名、枚举和结构体名使用 CamelCase，函数和变量名使用 snake_case。
    - **文档注释**：使用 /// 为公共接口添加文档说明。
    - **模块化**：根据功能将代码组织到不同的模块或文件中。

# 指导原则

## Rust 最佳实践
- **利用标准特性**：当类型 `T` 实现了 `PartialEq`、`Ord` 等标准特性时，直接使用这些特性提供的功能，避免传递自定义的比较函数或谓词。
- **泛型与类型安全**：使用泛型 `T` 来替代 C/C++ 中的 `void*`，使数据结构和函数能够处理任意类型的数据，同时保持类型安全。
- **所有权和借用机制**：遵循 Rust 的所有权规则，使用引用或智能指针(Box、Rc、RefCell、Arc、Mutex、RwLock等)，避免使用裸指针，确保内存安全。
- **错误处理**：使用 `Option<T>`、`Result<T, E>` 等类型处理可能的错误或空值，增强代码的健壮性。
- **利用标准库数据结构**：优先使用 Rust 标准库中的数据结构（如 `Vec<T>`、`HashMap<K, V>`）来替代手动管理的内存和数据结构。
- **函数指针**：利用 Rust 的标准特性（例如，实现 Ord、Eq 等 trait），避免传入函数指针或闭包。

## Rust 代码风格
- **文档注释**：使用 Rust 风格的文档注释 `///`，为代码添加清晰的说明，便于他人理解和维护。
- **命名规范**：遵循 Rust 的命名规范，使用驼峰命名法（`CamelCase`）命名类型和结构体和枚举，使用蛇形命名法（`snake_case`）命名函数和变量。

## 避免冗余内容：
- **仅转译给定的 C/C++ 代码**：不需要添加未提供的结构体、函数或类型定义，也不需要输出 `main` 函数或使用示例。
- **简化结构体**：保留在 Rust 中仍然必要的字段，删除因使用标准库而变得多余的字段。
- **避免不必要的函数参数**：如果功能可以通过标准特性实现，不要添加额外的函数参数。

请按照上述要求和指导原则，将提供的 C/C++ 代码转译为等价的 Rust 代码。特别注意：
- **当类型 `T` 实现了标准特性时，直接使用这些特性**，不要引入额外的函数参数（如比较函数或谓词函数）。
- **避免不必要的泛型参数或函数参数**，利用标准库和特性提供的功能。
- **在转译过程中，展示你的思维过程和每一步的理解与决策**。
- 你应该为代码编写符合Rust标准和最佳实践的文档注释，文档注释应使用三斜线语法（///）并放置在函数、结构体、枚举或模块定义之前。请确保文档注释中包含功能说明、参数描述、返回值说明和错误和异常情况说明，不需要编写示例代码。

# 格式要求
- **思维过程**：在转译过程中，展示你的思维过程和每一步的理解与决策。
- **最终代码**：在思维过程之后，给出转译后 Rust 代码，无需给出文件全部内容，只需转译当前任务中的代码。
最终代码应该在**1个** Markdown Json 代码块中，不可以由多个 JSON 代码块，请遵循以下格式：
{% include "partials/json_schema.prompt" %}

依次考虑上述要求和指导原则，逐步转译。Let's step by step.
值得注意的是，你不可以偷懒使用类似于 "// ..." 的注释来省略重复性的内容。
{#在开始实际转译之前，你需要进行深度推理分析和思考：#}
{### 步骤#1：理解代码的功能逻辑和结构#}
{#通读待转译的代码，全面理解其功能、结构和实现逻辑#}
{#{% if "struct" in node_types or "enum" in node_types or "union" in node_types %}#}
{#- 对于数据结构：#}
{#    - 列举出所有待转译的结构体、联合体、枚举等，理解他们每个字段的含义及作用；#}
{#    - 确定每个数据结构的含义和作用，分析其在代码中的使用场景；#}
{#    - 如果数据结构涉及内存管理，请详细说明。#}
{#{% elif "function" in node_types %}#}
{#- 对于函数：#}
{#    - 列出所有待转译的函数，说明他们的输入、输出、执行逻辑以及错误处理方式；#}
{#    - 确定每个函数的功能和作用，并使用伪代码描述其执行逻辑；#}
{#{% elif "typedef" in node_types %}#}
{#- 对于类型声明：#}
{#    - 列举出所有待转译的类型声明，说明他们的作用和使用场景；#}
{#{% endif %}#}
{### 步骤#2：确定转译方式和规范#}
{#考虑C/C++语言与Rust语言的差异，确定如何充分利用Rust语言特性，分析哪部分代码需要转译，哪部分代码可以直接使用Rust语言特性而无需转译。#}
{#{% if "struct" in node_types or "enum" in node_types or "union" in node_types %}#}
{#- 对于数据结构：#}
{#    - 重新设计数据结构字段，删除多余的字段，并优化字段名称。#}
{#    - 优先使用 Rust 标准库中的数据结构（如 `Vec<T>`、`HashMap<K, V>`）来替代手动管理的内存和数据结构。#}
{#    - 考虑为结构体或枚举实现常用派生特性 Debug、Clone、PartialEq、Eq 等特性。#}
{#    - 选择合适的智能指针（Box、Rc、RefCell、Arc、Mutex、RwLock等），替代裸指针，确保内存安全。#}
{#{% elif "function" in node_types %}#}
{#- 对于函数：#}
{#    - **是否需要转译为Rust代码**：考虑 Rust 中是否存在对应的标准库函数或 Debug、Clone、PartialEq、Ord 等特性中已经定义的方法，避免重复实现。若当前函数的功能可以完全被标准库函数或标准特性替代，则无需转译，给出说明即可，#}
{#        - 例如：整型类型的比较，可以是用 `PartialEq` 特性来实现，无需手动实现整型类型的比较函数。#}
{#    - 适当修改与某些数据结构相关的函数名，同时将其重构为基于该数据结构的 `impl` 方法，而不是单独的自由函数，以提高代码的模块化和可读性，尤其是方法名为 `数据结构名_函数名` 的函数。#}
{#    - 考虑 Rust 的所有权模型和引用借用关系，设计合理的函数参数和返回值。#}
{#    - 使用 Result 或 Option 来处理可能的错误或无效情况，而不是返回错误码。#}
{#    - 对于函数参数，优先考虑使用标准特性（如 PartialEq、Ord）实现功能，避免引入额外的函数参数。#}
{#{% elif "typedef" in node_types %}#}
{#- 对于类型声明：#}
{#    - 对于 void* 类型，优先考虑使用泛型 <T> 来替代，提高类型安全性。#}
{#    - 对于函数指针类型，优先考虑使用 Rust 的标准特性（如 PartialEq、Ord）替代，避免引入额外的类型定义。#}
{#{% endif %}#}
{#- 对于未完成的 C 代码：#}
{#    - 若 C 代码中使用 TODO 标记，则在转译过程中，使用 Rust 的 `unimplemented!` 宏或 `todo!` 宏来标记未完成的部分，防止遗漏。#}
{### 步骤#3：逐步转译代码#}
{#考虑是否需要显式地转译代码为 Rust 代码，保证代码的简洁性和可读性。#}
{#不要额外转译其他代码，只需转译当前任务中的代码，同时也不要添加任何未提及的方法和测试等。#}
{#你应该为代码编写符合Rust标准和最佳实践的文档注释，文档注释应使用三斜线语法（///）并放置在函数、结构体、枚举或模块定义之前。请确保文档注释中包含功能说明、参数描述、返回值说明和错误和异常情况说明，不需要编写示例代码。#}

{## 格式要求#}
{#- **思维过程**：在转译过程中，展示你的思维过程和每一步的理解与决策。#}
{#- **最终代码**：在思维过程之后，给出最终的 Rust 代码，遵循格式要求。#}
{#最终代码应该在**1个** Markdown Json 代码块中，不可以由多个 JSON 代码块，请遵循以下格式：#}
{#{% include "partials/json_schema.prompt" %}#}
{##}
{#依次考虑上述要求和指导原则，逐步转译。Let's step by step.#}