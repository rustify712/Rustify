用户会为你提供由C语言转译而来的 Rust 代码（可能有多个rust文件），一份针对原C语言代码的测试代码，请你根据原C语言测试代码生成对应的 Rust 测试代码。

## 原C语言测试代码：
{{c_test_code}}
## crate 名称：{{crate_name}}
{### 被测模块：#}
{#{% for rust_module_name in rust_module_names %}#}
{#{{rust_module_name}}#}
{#{% endfor %}#}
## 被测代码：
{% include "partials/files.prompt" %}


在分析生成对应的 Rust 测试代码时，请你按照以下步骤进行：
### 步骤1:
    - 分析 C 语言测试代码：逐一解析每个测试函数，从中提取测试用例的核心要素，包括：
        - 测试输入：记录测试函数中用于验证功能的输入数据及其类型。
        - 测试输出：提取测试函数的预期输出，包括返回值、状态码或其他检查点。
        - 测试逻辑：梳理测试代码的执行流程，包括边界条件、断言语句及特定分支路径，
                   **注意不要遗漏 C 语言测试代码中的断言，例如在循环中是否需要对每一次操作的结果都进行断言**。
        **注意，所有测试的输入输出值都必须与原c语言保持一致**

### 步骤2：
    - 分析 Rust 待测代码：解析 Rust 待测代码的关键特性，列出:
        - 核心数据结构：梳理 Rust 中定义的结构体、枚举及其关联的字段或方法。
        - 关键函数：列出需要测试的 Rust 函数，包括其参数类型、返回值类型、泛型及生命周期约束等。
### 步骤3：
    - 编写 Rust 测试代码：基于前两步的分析结果，为当前 Rust 代码编写测试程序，所有测试用例的输入、输出与测试逻辑必须与原c语言测试代码保持一致。

## **注意**
- 转译后的 Rust 测试代码是针对提供的 Rust 代码的，请确保其能够正确调用其中的函数，并能够正确运行
- 对于泛型T类型，需要根据上下文为其指定具体类型而非`_`，确保测试代码能够正确编译。
- **不要使用任何未在Cargo.toml中声明的模块。**
- 如果存在无需转译或者无法转译的测试用例，请明确说明原因，**注意不需要写一个空的测试函数**
- 导入模块时，不要使用 `create` 或 `super` 关键字，**必须**使用crate名称。
{#- 在 Rust 测试代码中，一般使用 use 语句引入待测模块。请根据"use::crate名称::待测模块名称::xxx"的格式，正确地使用 use 语句#}

**重要**：若被测试的 Rust 代码为空，则**一定不要**为其编写测试代码，直接返回空的测试代码块即可。
请在最后返回转译生成 Rust 测试代码块（多个rust模块也只生成一个总体的测试代码块），用```rust包裹。
Let's step by step.