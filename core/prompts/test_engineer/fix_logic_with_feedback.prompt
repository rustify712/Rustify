用户在执行测试时出现了测试用例不通过的情况，请你根据提供的测试代码、被测代码和测试错误信息，综合考虑之前的对话修错记录
分析测试不通过的原因，并通过修改被测代码使其能够通过测试。

{% include "partials/files.prompt" %}
## 被测模块:
{% for rust_file in related_rust_files %}
{{rust_file}}
{% endfor %}
## 测试程序: {{ test_filepath }}
## 测试函数名称
{{test_case_name}}
## 测试错误信息
{{error_info}}

你应该按照以下步骤进行分析：

### 步骤#1：**测试错误信息分析**
**目标**：从测试错误信息出发，理解测试未通过的原因。
**步骤**：
    1.查看错误信息：根据测试框架的输出，查找错误类型（运行时错误或逻辑错误）
        - 如果是运行时错误，请根据输出的报错或堆栈信息，分析错误位置和原因
        - 如果是逻辑错误，请分析预期输出与实际输出之间的区别并根据堆栈分析错误产生的调用链
    2.检查测试输出：若有详细的打印输出，查看是否有异常数据或意外的中间状态。
    3.根据上一轮对话确定测试用例是否不合理

### 步骤#2：**测试代码与被测代码分析**
**目标**：从测试代码出发，深入分析测试执行过程中的调用链及每一部分的逻辑。
**步骤**：
1. 根据测试函数名称定位执行失败的测试函数，分析测试函数的测试输入、测试逻辑与预期输出，**对比分析被对象的预期逻辑和测试函数的逻辑是否相符，如果不符，请修改测试函数**
2. 详细分析报错堆栈信息，追溯到被测代码，详细列出报错堆栈中每个函数、方法或模块的具体实现，特别是与测试失败相关的部分
3. 根据错误信息，定位调用链中出现问题的模块，分析说明错误的本质以及该错误是如何造成测试用例失败的

### 步骤#3：**分析解决方案**
**目标**：基于前两步的分析和历史对话，提出问题的解决方案
**步骤**：
1. 总结步骤#2中的错误分析结果，提出可能的修改方案
2. **综合考虑历史对话，总结之前的解决方案**，说明没有成功修改错误的原因并给出调整后的方案。
3. 基于以上分析，详细阐述最终的修改方案，对比列出修改前后的逻辑差异，并深入阐述该修改方案是如何使得测试通过的

### 步骤#4：**修改并返回最终代码**
**目标**：根据前面的分析，修改代码，在修复错误后，将最终的测试代码或被测模块代码返回给用户，这取决于你修改了哪一部分代码。
**步骤**：
1. 总结前面分析得出的最终解决方案，明确列出代码中需要修改的部分，优先确保测试代码中的测试逻辑与断言是正确的
2. 根据总结后的解决方案，修改测试代码或者被测代码，确保符合预期行为

**注意，如果有重构规则且满足重构的条件，请你按照特殊规则重构被测代码**

{% if rebuild %}
## 重构规则：
### 规则1
    - **重构条件**：原代码使用了Box智能指针且由于Box引入了所有权或生命周期的复杂性导致测试难以通过
    - **重构规则**：请使用Rust中的RefCell和Rc机制重构代码
{% endif %}


先输出你的分析过程，要求严格执行每一个步骤及其子步骤。
最终代码应遵守以下格式:
```rust
// filepath: 修改的文件路径（与用户提供的路径相同，不允许省略前缀）
修改后的全部代码（**要求返回完整的代码，不能只返回修改后的部分代码，不需要行号**）
```
Let's step by step.