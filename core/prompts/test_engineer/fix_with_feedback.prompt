用户正在运行一个 Rust 模块的测试程序, 但程序运行过程中出现错误。
用户将向你提供被测模块的代码, 测试程序, 部分项目文件的内容以及相关的错误信息, 请你帮助用户找出错误并解决问题。

{% include "partials/files.prompt" %}
## 被测模块:
{% for rust_file in related_rust_files %}
{{rust_file}}
{% endfor %}
## 测试程序: {{ test_filepath }}

## 错误信息
{% for error in errors %}
{{ error.rendered }}
{% endfor %}

## crate名称：
{{crate_name}}

## 你应该按照以下步骤进行：
### 步骤#1：**分析被测代码**
**目标**：理解被测代码的模块结构和逻辑，明确其对测试代码的要求。
**步骤**：
1.检查模块结构和命名空间：
    - 确认被测代码的模块划分和命名空间。
    - 明确被测模块是否对测试代码暴露了必要的接口（pub 或 pub(crate)）。
2.分析函数定义：
    - 检查被测代码中公开的函数签名，包括参数类型、返回值类型、泛型约束和生命周期标注。
    - 确认函数是否具备测试代码调用所需的功能。
3.检查数据结构：
    - 确认被测代码中定义的结构体、枚举和 Trait 是否符合测试代码的使用场景。
    - 分析其属性的可见性和类型（如是否需要 pub，是否使用了泛型）。
4.明确边界条件和依赖：
    - 分析被测代码中的核心逻辑，确认其边界条件或特殊约束（如泛型参数是否必须实现特定的 Trait）。
    - 检查被测模块是否依赖其他模块，测试代码是否满足这些依赖。
### 步骤#2：**分析测试代码**
**目标**：结合用户提供的测试代码和编译器的错误信息，定位语法错误。
**步骤**：
1. 检查测试代码与编译器错误信息的对应关系：
    - 确定编译器错误发生的行号以及相关上下文。
    - 确保测试代码中每个出错的语法点都能对应到编译器提供的信息。
2. 理解测试代码的语法问题：
    - 是否存在模块导入错误。
    - 是否有未初始化的变量或类型不匹配。
    - 测试函数是否符合 Rust 测试规范（如 #[test] 注解、无参数、无返回值）。
3. 列出所有语法问题：
    - 为每个错误记录具体的代码片段、位置和可能的修复方法。
### 步骤#3：**分析编译器错误信息**
**目标**：通过分析编译器错误信息，确定语法错误的根本原因。
**步骤**：
1. 逐条解析错误信息：
    - 错误描述：提取编译器错误的类型（如未找到模块、类型不匹配、函数调用签名不匹配等）。
    - 错误位置：记录错误发生的具体行号和文件路径。
2. 结合测试代码上下文：
    - 判断错误是否由模块路径问题、函数签名不匹配、缺少 Trait 实现等引发。
    - 如果错误信息指向被测模块，但问题实际出在测试代码中，确认测试代码的使用是否符合被测模块的定义。
3. 归纳错误类别：
    - 将所有错误按问题类型分类，形成清晰的错误清单。
### 步骤#4：**修复问题**
**目标**：根据错误原因，修改测试代码或被测模块代码，以解决错误。由于被测模块已经通过语法检测，请优先修改测试代码。

### 步骤#5：**返回最终代码**
**目标**：在修复错误后，将最终的测试代码或被测模块代码返回给用户，这取决于你修改了哪一个文件的代码。
最终代码应遵守以下格式:
```rust
// filepath: 修改的文件路径（**与用户提供的路径相同，不允许省略前缀**）
修改后的全部代码（**无论你修改了哪一个文件，都必须返回该文件的完整代码**）
```